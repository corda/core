package net.corda.node.amqp.jms

import net.corda.core.context.Trace
import net.corda.core.serialization.deserialize
import net.corda.core.serialization.serialize
import net.corda.core.utilities.Id
import net.corda.core.utilities.Try
import net.corda.core.utilities.contextLogger
import net.corda.nodeapi.METHOD_NAME_FIELD_NAME_ALT
import net.corda.nodeapi.RPCApi
import net.corda.nodeapi.RPC_ID_FIELD_NAME_ALT
import net.corda.nodeapi.RPC_ID_TIMESTAMP_FIELD_NAME_ALT
import net.corda.nodeapi.RPC_SESSION_ID_FIELD_NAME_ALT
import net.corda.nodeapi.RPC_SESSION_ID_TIMESTAMP_FIELD_NAME_ALT
import net.corda.serialization.internal.AMQP_RPC_CLIENT_CONTEXT
import net.corda.testing.driver.DriverParameters
import net.corda.testing.driver.driver
import org.apache.qpid.jms.JmsConnectionFactory
import org.apache.qpid.jms.JmsTopic
import org.junit.Test
import java.time.Instant
import java.util.concurrent.CountDownLatch
import java.util.concurrent.TimeUnit
import javax.jms.BytesMessage
import javax.jms.CompletionListener
import javax.jms.ConnectionFactory
import javax.jms.DeliveryMode
import javax.jms.ExceptionListener
import javax.jms.Message
import javax.jms.Session
import kotlin.test.assertNotNull
import kotlin.test.assertTrue

/**
 * This test uses JMS AMQP API to demonstrate that it is possible to perform an RPC call.
 */
class AmqpRpcTests {

    companion object {
        private val logger = contextLogger()

        const val TAG_FIELD_NAME = "tag" // RPCApi.TAG_FIELD_NAME
        const val RPC_REQUEST = 0 // RPCApi.ClientToServer.Tag.RPC_REQUEST
        const val HDR_VALIDATED_USER = "_AMQ_VALIDATED_USER" // org.apache.activemq.artemis.api.core.Message.HDR_VALIDATED_USER

        private fun Trace.InvocationId.mapTo(message: Message) = mapTo(message, RPC_ID_FIELD_NAME_ALT, RPC_ID_TIMESTAMP_FIELD_NAME_ALT)

        private fun Trace.SessionId.mapTo(message: Message) = mapTo(message, RPC_SESSION_ID_FIELD_NAME_ALT, RPC_SESSION_ID_TIMESTAMP_FIELD_NAME_ALT)

        private fun Id<String>.mapTo(message: Message, valueProperty: String, timestampProperty: String) {
            message.setStringProperty(valueProperty, value)
            message.setLongProperty(timestampProperty, timestamp.toEpochMilli())
        }
    }

    @Test(timeout=300_000)
    fun `RPC over AMQP`() {
        driver(DriverParameters(startNodesInProcess = true, notarySpecs = emptyList())) {
            val node = startNode().get()
            val connectionFactory: ConnectionFactory = JmsConnectionFactory("amqp://${node.rpcAddress}")
            val rpcUser = node.rpcUsers.first()
            connectionFactory.createConnection(rpcUser.username, rpcUser.password).use { connection ->

                connection.exceptionListener = ExceptionListener { exception -> logger.error("Exception on connection: $connection", exception) }
                // Start connection
                connection.start()

                // Create a session
                val session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE)
                val rpcServerQueueName = RPCApi.RPC_SERVER_QUEUE_NAME // Note: Server side queue created with MULTICAST routing type,
                // therefore for this "queue" we should use JmsTopic when publishing
                val sender = session.createProducer(JmsTopic(rpcServerQueueName))

                val replyId= Trace.InvocationId.newInstance()
                val sessionId = Trace.SessionId.newInstance()
                // Create specific queue name for replies
                // Note: We cannot create temporary queues as name is generated by the session and we are not allowed to create temporary queues with arbitrary names
                // Note: The queue is not actually created on server side after this call - this is just a provision
                // until consumer is created later on, ready-to-send results are being cached on RPCServer side
                val replyQueue = session.createQueue("${RPCApi.RPC_CLIENT_QUEUE_NAME_PREFIX}.${rpcUser.username}.AmqpRpcTests")

                val message = session.createBytesMessage()
                message.apply {
                    jmsReplyTo = replyQueue
                    setIntProperty(TAG_FIELD_NAME, RPC_REQUEST)
                    replyId.mapTo(this)
                    sessionId.mapTo(this)
                    setStringProperty(METHOD_NAME_FIELD_NAME_ALT, "currentNodeTime")
                    val serialisedArguments = emptyList<Unit>().serialize(context = AMQP_RPC_CLIENT_CONTEXT)
                    writeBytes(serialisedArguments.bytes)
                    setStringProperty(HDR_VALIDATED_USER, rpcUser.username) // TODO: We can pretend to be someone else and elevate our permissions
                }

                val sentLatch = CountDownLatch(1)

                val instantBeforeSend = Instant.now()
                logger.info("About to send")
                sender.send(message, DeliveryMode.NON_PERSISTENT, Message.DEFAULT_PRIORITY, Message.DEFAULT_TIME_TO_LIVE, object : CompletionListener {
                    override fun onException(message: Message, exception: Exception) {
                        logger.error(message.toString(), exception)
                    }

                    override fun onCompletion(message: Message) {
                        logger.info("Message successfully sent: $message")
                        sentLatch.countDown()
                    }
                })

                assertTrue(sentLatch.await(10, TimeUnit.SECONDS))
                logger.info("Obtaining response")
                session.createConsumer(replyQueue).use { consumer ->
                    // Receive response from node
                    val serverResponse = consumer.receive(5000) as BytesMessage
                    assertNotNull(serverResponse)
                    val bytes = ByteArray(serverResponse.bodyLength.toInt())
                    serverResponse.readBytes(bytes)
                    val maybeInstant = bytes.deserialize<Try<Instant>>(context = AMQP_RPC_CLIENT_CONTEXT)
                    assertTrue(maybeInstant.getOrThrow().isAfter(instantBeforeSend))
                }
            }
        }
    }
}